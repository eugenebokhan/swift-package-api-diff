// swift-interface-format-version: 1.0
// swift-compiler-version: Swift version 5.3-dev (LLVM c377dba73da1364, Swift 4419f879adac304)
// swift-module-flags: -target x86_64-apple-macosx10.9 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftOSLogTestHelper -swift-version 5 -O -enforce-exclusivity=unchecked -module-name OSLogTestHelper
import ObjectiveC
import Swift
@usableFromInline
@inline(never) internal func isLoggingEnabled() -> Swift.Bool
public let _noopClosure: (Swift.String, Swift.UnsafeBufferPointer<Swift.UInt8>) -> ()
@_semantics("oslog.requires_constant_arguments") @_transparent @_optimize(none) public func _osLogTestHelper(_ message: OSLogTestHelper.OSLogMessage, assertion: (Swift.String, Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.Void = _noopClosure) {
  // Compute static constants first so that they can be folded by
  // OSLogOptimization pass.
  let formatString = message.interpolation.formatString
  let preamble = message.interpolation.preamble
  let argumentCount = message.interpolation.argumentCount
  let bufferSize = message.bufferSize
  let objectCount = message.interpolation.objectArgumentCount
  let stringCount = message.interpolation.stringArgumentCount
  let uint32bufferSize = UInt32(bufferSize)
  let argumentClosures = message.interpolation.arguments.argumentClosures

  let formatStringPointer = _getGlobalStringTablePointer(formatString)

  // Code that will execute at runtime.
  if (!isLoggingEnabled()) {
    return
  }
  let bufferMemory = UnsafeMutablePointer<UInt8>.allocate(capacity: bufferSize)
  // Buffer for storing NSObjects and strings to keep them alive until the
  // _os_log_impl_test call completes.
  let objectArguments = createStorage(capacity: objectCount, type: NSObject.self)
  let stringArgumentOwners = createStorage(capacity: stringCount, type: Any.self)

  var currentBufferPosition = bufferMemory
  var objectArgumentsPosition = objectArguments
  var stringArgumentOwnersPosition = stringArgumentOwners
  serialize(preamble, at: &currentBufferPosition)
  serialize(argumentCount, at: &currentBufferPosition)
  argumentClosures.forEach {
    $0(&currentBufferPosition,
       &objectArgumentsPosition,
       &stringArgumentOwnersPosition)
  }

  _os_log_impl_test(
    assertion,
    formatString,
    formatStringPointer,
    bufferMemory,
    uint32bufferSize)

  // The following operation extends the lifetime of objectArguments and
  // stringArgumentOwners till this point. This is necessary because the
  // assertion is passed internal pointers to the objects/strings stored
  // in these arrays, as in the actual os log implementation.
  destroyStorage(objectArguments, count: objectCount)
  destroyStorage(stringArgumentOwners, count: stringCount)
  bufferMemory.deallocate()
}
@usableFromInline
@inline(never) internal func _os_log_impl_test(_ assertion: (Swift.String, Swift.UnsafeBufferPointer<Swift.UInt8>) -> Swift.Void, _ formatString: Swift.String, _ formatStringPointer: Swift.UnsafePointer<Swift.CChar>, _ bufferMemory: Swift.UnsafeMutablePointer<Swift.UInt8>, _ bufferSize: Swift.UInt32)
@_semantics("constant_evaluable") @inlinable @_optimize(none) public var maxOSLogArgumentCount: Swift.UInt8 {
  get { return 48 }
}
@_transparent @_alwaysEmitIntoClient internal var logBitsPerByte: Swift.Int {
  @_transparent get { return 3 }
}
@frozen public struct OSLogInterpolation : Swift.StringInterpolationProtocol {
  @usableFromInline
  internal var formatString: Swift.String
  @usableFromInline
  internal var arguments: OSLogTestHelper.OSLogArguments
  @usableFromInline
  internal enum ArgumentType {
    case scalar, count, string, pointer, object, mask
    @inlinable internal var rawValue: Swift.UInt8 {
      get {
      switch self {
      case .scalar:
        return 0
      case .count:
        return 1
      case .string:
        return 2
      case .pointer:
        return 3
      case .mask:
        return 7
      default: //.object
        return 4
      }
    }
    }
    @usableFromInline
    internal static func == (a: OSLogTestHelper.OSLogInterpolation.ArgumentType, b: OSLogTestHelper.OSLogInterpolation.ArgumentType) -> Swift.Bool
    @usableFromInline
    internal var hashValue: Swift.Int {
      @usableFromInline
      get
    }
    @usableFromInline
    internal func hash(into hasher: inout Swift.Hasher)
  }
  @usableFromInline
  internal var preamble: Swift.UInt8
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal var privateBitMask: Swift.UInt8 {
    get { 0x1 }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal var nonScalarBitMask: Swift.UInt8 {
    get { 0x2 }
  }
  @usableFromInline
  internal var argumentCount: Swift.UInt8
  @usableFromInline
  internal var totalBytesForSerializingArguments: Swift.Int
  @usableFromInline
  internal var stringArgumentCount: Swift.Int
  @usableFromInline
  internal var objectArgumentCount: Swift.Int
  @_semantics("oslog.interpolation.init") @_semantics("constant_evaluable") @inlinable @_optimize(none) public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int) {
    // Since the format string and the arguments array are fully constructed
    // at compile time, the parameters are ignored.
    formatString = ""
    arguments = OSLogArguments()
    preamble = 0
    argumentCount = 0
    totalBytesForSerializingArguments = 0
    stringArgumentCount = 0
    objectArgumentCount = 0
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public mutating func appendLiteral(_ literal: Swift.String) {
    formatString += literal.percentEscapedString
  }
  @inlinable @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getArgumentHeader(privacy: OSLogTestHelper.OSLogPrivacy, type: OSLogTestHelper.OSLogInterpolation.ArgumentType) -> Swift.UInt8 {
    return (type.rawValue &<< 4) | privacy.argumentFlag
  }
  @inlinable @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getUpdatedPreamble(privacy: OSLogTestHelper.OSLogPrivacy, isScalar: Swift.Bool) -> Swift.UInt8 {
    var preamble = self.preamble
    if privacy.isAtleastPrivate {
      preamble |= privateBitMask
    }
    if !isScalar || privacy.hasMask {
      preamble |= nonScalarBitMask
    }
    return preamble
  }
  public typealias StringLiteralType = Swift.String
}
extension String {
  @inlinable internal var percentEscapedString: Swift.String {
    @_semantics("string.escapePercent.get") @_effects(readonly) @_optimize(none) get {
      return self
        .split(separator: "%", omittingEmptySubsequences: false)
        .joined(separator: "%%")
    }
  }
}
@frozen public struct OSLogMessage : Swift.ExpressibleByStringInterpolation, Swift.ExpressibleByStringLiteral {
  public let interpolation: OSLogTestHelper.OSLogInterpolation
  @inlinable @_optimize(none) @_semantics("oslog.message.init_interpolation") @_semantics("constant_evaluable") public init(stringInterpolation: OSLogTestHelper.OSLogInterpolation) {
    self.interpolation = stringInterpolation
  }
  @inlinable @_optimize(none) @_semantics("oslog.message.init_stringliteral") @_semantics("constant_evaluable") public init(stringLiteral value: Swift.String) {
    var s = OSLogInterpolation(literalCapacity: 1, interpolationCount: 0)
    s.appendLiteral(value)
    self.interpolation = s
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public var bufferSize: Swift.Int {
    get {
    // The two additional bytes is for the preamble and argument count.
    return interpolation.totalBytesForSerializingArguments + 2
  }
  }
  public typealias StringInterpolation = OSLogTestHelper.OSLogInterpolation
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@usableFromInline
internal typealias ByteBufferPointer = Swift.UnsafeMutablePointer<Swift.UInt8>
@usableFromInline
internal typealias ObjectStorage<T> = Swift.UnsafeMutablePointer<T>?
@usableFromInline
internal typealias ArgumentClosures = [(inout OSLogTestHelper.ByteBufferPointer, inout OSLogTestHelper.ObjectStorage<ObjectiveC.NSObject>, inout OSLogTestHelper.ObjectStorage<Any>) -> ()]
@usableFromInline
@frozen internal struct OSLogArguments {
  @usableFromInline
  internal var argumentClosures: OSLogTestHelper.ArgumentClosures
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal init() {
    argumentClosures = []
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ header: Swift.UInt8) {
    argumentClosures.append({ (position, _, _) in
      serialize(header, at: &position)
    })
  }
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize(_ value: Swift.UInt8, at bufferPosition: inout OSLogTestHelper.ByteBufferPointer) {
  bufferPosition[0] = value
  bufferPosition += 1
}
@_alwaysEmitIntoClient @inline(__always) internal func createStorage<T>(capacity: Swift.Int, type: T.Type) -> OSLogTestHelper.ObjectStorage<T> {
  return
    capacity == 0 ?
      nil :
      UnsafeMutablePointer<T>.allocate(capacity: capacity)
}
@_alwaysEmitIntoClient @inline(__always) internal func initializeAndAdvance<T>(_ storageOpt: inout OSLogTestHelper.ObjectStorage<T>, to value: T) {
  // This if statement should get optimized away.
  if let storage = storageOpt {
    storage.initialize(to: value)
    storageOpt = storage.advanced(by: 1)
  }
}
@_alwaysEmitIntoClient @inline(__always) internal func destroyStorage<T>(_ storageOpt: OSLogTestHelper.ObjectStorage<T>, count: Swift.Int) {
  // This if statement should get optimized away.
  if let storage = storageOpt {
    storage.deinitialize(count: count)
    storage.deallocate()
  }
}
@frozen public struct OSLogIntegerFormatting {
  @usableFromInline
  internal var radix: Swift.Int
  @usableFromInline
  internal var explicitPositiveSign: Swift.Bool
  @usableFromInline
  internal var includePrefix: Swift.Bool
  @usableFromInline
  internal var uppercase: Swift.Bool
  @usableFromInline
  internal var minDigits: (() -> Swift.Int)?
  @usableFromInline
  @_transparent internal init(radix: Swift.Int = 10, explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false, minDigits: (() -> Swift.Int)?) {
    self.radix = radix
    self.explicitPositiveSign = explicitPositiveSign
    self.includePrefix = includePrefix
    self.uppercase = uppercase
    self.minDigits = minDigits
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func decimal(explicitPositiveSign: Swift.Bool = false, minDigits: @autoclosure @escaping () -> Swift.Int) -> OSLogTestHelper.OSLogIntegerFormatting {
    return OSLogIntegerFormatting(
      radix: 10,
      explicitPositiveSign: explicitPositiveSign,
      minDigits: minDigits)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func decimal(explicitPositiveSign: Swift.Bool = false) -> OSLogTestHelper.OSLogIntegerFormatting {
    return OSLogIntegerFormatting(
      radix: 10,
      explicitPositiveSign: explicitPositiveSign,
      minDigits: nil)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var decimal: OSLogTestHelper.OSLogIntegerFormatting {
    get { .decimal() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hex(explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false, minDigits: @autoclosure @escaping () -> Swift.Int) -> OSLogTestHelper.OSLogIntegerFormatting {
    return OSLogIntegerFormatting(
      radix: 16,
      explicitPositiveSign: explicitPositiveSign,
      includePrefix: includePrefix,
      uppercase: uppercase,
      minDigits: minDigits)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hex(explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogIntegerFormatting {
    return OSLogIntegerFormatting(
      radix: 16,
      explicitPositiveSign: explicitPositiveSign,
      includePrefix: includePrefix,
      uppercase: uppercase,
      minDigits: nil)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var hex: OSLogTestHelper.OSLogIntegerFormatting {
    get { .hex() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func octal(explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false, minDigits: @autoclosure @escaping () -> Swift.Int) -> OSLogTestHelper.OSLogIntegerFormatting {
    OSLogIntegerFormatting(
      radix: 8,
      explicitPositiveSign: explicitPositiveSign,
      includePrefix: includePrefix,
      uppercase: uppercase,
      minDigits: minDigits)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func octal(explicitPositiveSign: Swift.Bool = false, includePrefix: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogIntegerFormatting {
    OSLogIntegerFormatting(
      radix: 8,
      explicitPositiveSign: explicitPositiveSign,
      includePrefix: includePrefix,
      uppercase: uppercase,
      minDigits: nil)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var octal: OSLogTestHelper.OSLogIntegerFormatting {
    get { .octal() }
  }
}
extension OSLogIntegerFormatting {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal var _prefix: Swift.String {
    get {
    guard includePrefix else { return "" }
    switch radix {
    case 2: return "0b"
    case 8: return "0o"
    case 16: return "0x"
    default: return ""
    }
  }
  }
}
extension OSLogIntegerFormatting {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal static func formatSpecifierLengthModifier<I>(_ type: I.Type) -> Swift.String? where I : Swift.FixedWidthInteger {
    // IEEE Std 1003.1-2017, length modifiers:
    switch type {
    //   hh - d, i, o, u, x, or X conversion specifier applies to
    // (signed|unsigned) char
    case is CChar.Type: return "hh"
    case is CUnsignedChar.Type: return "hh"

    //   h  - d, i, o, u, x, or X conversion specifier applies to
    // (signed|unsigned) short
    case is CShort.Type: return "h"
    case is CUnsignedShort.Type: return "h"

    case is CInt.Type: return ""
    case is CUnsignedInt.Type: return ""

    //   l  - d, i, o, u, x, or X conversion specifier applies to
    // (signed|unsigned) long
    case is CLong.Type: return "l"
    case is CUnsignedLong.Type: return "l"

    //   ll - d, i, o, u, x, or X conversion specifier applies to
    // (signed|unsigned) long long
    case is CLongLong.Type: return "ll"
    case is CUnsignedLongLong.Type: return "ll"

    default: return nil
    }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_effects(readonly) internal func formatSpecifier<I>(for type: I.Type, align: OSLogTestHelper.OSLogStringAlignment, privacy: OSLogTestHelper.OSLogPrivacy) -> Swift.String where I : Swift.FixedWidthInteger {
    // Based on IEEE Std 1003.1-2017
    // `d`/`i` is the only signed integral conversions allowed
    if (type.isSigned && radix != 10) {
      fatalError("Signed integers must be formatted using .decimal")
    }

    // IEEE: Each conversion specification is introduced by the '%' character
    // after which the following appear in sequence:
    //   1. Zero or more flags (in any order), which modify the meaning of the
    //      conversion specification.
    //   2. An optional minimum field width (for alignment). If the converted
    //      value has fewer bytes than the field width, it shall be padded with
    //      <space> characters by default on the left; it shall be padded on the
    //      right if the left-adjustment flag ( '-' ), is given to the
    //      field width.
    //   3. An optional precision that gives the minimum number of digits to
    //      display for the d, i, o, u, x, and X conversion specifiers.
    //   4. An optional length modifier that specifies the size of the argument.
    //   5. A conversion specifier character that indicates the type of
    //      conversion to be applied.

    // Use Swift style prefixes rather than fprintf style prefixes.
    var specification = _prefix
    specification += "%"

    // Add privacy qualifier after % sign within curly braces. This is an
    // os log specific flag.
    if let privacySpecifier = privacy.privacySpecifier {
      specification += "{"
      specification += privacySpecifier
      specification += "}"
    }

    //
    // 1. Flags
    //
    // Use `+` flag if signed, otherwise prefix a literal `+` for unsigned.
    if explicitPositiveSign {
      // IEEE: `+` The result of a signed conversion shall always begin with a
      // sign ( '+' or '-' )
      if type.isSigned {
        specification += "+"
      } else {
        var newSpecification = "+"
        newSpecification += specification
        specification = newSpecification
      }
    }

    // IEEE: `-` The result of the conversion shall be left-justified within
    // the field. The conversion is right-justified if this flag is not
    // specified.
    if case .start = align.anchor {
      specification += "-"
    }

    // 2. Minimumn field width
    // IEEE: When field width is prefixed by `0`, leading zeros (following any
    // indication of sign or base) are used to pad to the field width rather
    // than performing space padding. If the '0' and '-' flags both appear,
    // the '0' flag is ignored. If a precision is specified, the '0' flag shall
    // be ignored.
    //
    // Commentary: `0` is prefixed to field width when the user doesn't want to
    // use precision (minDigits). This allows sign and prefix characters to be
    // counted towards field width (they wouldn't be counted towards precision).
    // This is more useful for floats, where precision is digits after the radix.
    // In our case, we're already handling prefix ourselves; we choose not to
    // support this functionality. In our case, alignment always pads spaces (
    // to the left or right) until the minimum field width is met.
    if let _ = align.minimumColumnWidth {
      // The alignment could be a dynamic value. Therefore, use a star here and pass it
      // as an additional argument.
      specification += "*"
    }

    // 3. Precision

    // Default precision for integers is 1, otherwise use the requested precision.
    // The precision could be a dynamic value. Therefore, use a star here and pass it
    // as an additional argument.
    if let _ = minDigits {
      specification += ".*"
    }

    // 4. Length modifier
    guard let lengthModifier =
      OSLogIntegerFormatting.formatSpecifierLengthModifier(type) else {
      fatalError("Integer type has unknown byte length")
    }
    specification += lengthModifier

    // 5. The conversion specifier
    switch radix {
    case 10:
      specification += type.isSigned ? "d" : "u"
    case 8:
      specification += "o"
    case 16:
      specification += uppercase ? "X" : "x"
    default:
      fatalError("radix must be 10, 8 or 16")
    }
    return specification
  }
}
@usableFromInline
internal enum OSLogCollectionBound {
  case start
  case end
  @usableFromInline
  internal static func == (a: OSLogTestHelper.OSLogCollectionBound, b: OSLogTestHelper.OSLogCollectionBound) -> Swift.Bool
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
}
@frozen public struct OSLogStringAlignment {
  @usableFromInline
  internal var minimumColumnWidth: (() -> Swift.Int)?
  @usableFromInline
  internal var anchor: OSLogTestHelper.OSLogCollectionBound
  @usableFromInline
  @_transparent internal init(minimumColumnWidth: (() -> Swift.Int)? = nil, anchor: OSLogTestHelper.OSLogCollectionBound = .end) {
    self.minimumColumnWidth = minimumColumnWidth
    self.anchor = anchor
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var none: OSLogTestHelper.OSLogStringAlignment {
    get { OSLogStringAlignment(anchor: .end)  }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func right(columns: @autoclosure @escaping () -> Swift.Int) -> OSLogTestHelper.OSLogStringAlignment {
    OSLogStringAlignment(minimumColumnWidth: columns, anchor: .end)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func left(columns: @autoclosure @escaping () -> Swift.Int) -> OSLogTestHelper.OSLogStringAlignment {
    OSLogStringAlignment(minimumColumnWidth: columns, anchor: .start)
  }
}
extension OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int, format: OSLogTestHelper.OSLogIntegerFormatting = .decimal, align: OSLogTestHelper.OSLogStringAlignment = .none, privacy: OSLogTestHelper.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Int32, format: OSLogTestHelper.OSLogIntegerFormatting = .decimal, align: OSLogTestHelper.OSLogStringAlignment = .none, privacy: OSLogTestHelper.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.UInt, format: OSLogTestHelper.OSLogIntegerFormatting = .decimal, align: OSLogTestHelper.OSLogStringAlignment = .none, privacy: OSLogTestHelper.OSLogPrivacy = .auto) {
    appendInteger(number, format: format, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func appendInteger<T>(_ number: @escaping () -> T, format: OSLogTestHelper.OSLogIntegerFormatting, align: OSLogTestHelper.OSLogStringAlignment, privacy: OSLogTestHelper.OSLogPrivacy) where T : Swift.FixedWidthInteger {
    guard argumentCount < maxOSLogArgumentCount else { return }
    formatString +=
      format.formatSpecifier(for: T.self, align: align, privacy: privacy)

    // If minimum column width is specified, append this value first. Note that
    // the format specifier would use a '*' for width e.g. %*d.
    if let minColumns = align.minimumColumnWidth {
      appendAlignmentArgument(minColumns)
    }

    // If the privacy has a mask, append the mask argument, which is a constant payload.
    // Note that this should come after the width but before the precision.
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }

    // If minimum number of digits (precision) is specified, append the
    // precision before the argument. Note that the format specifier would use
    // a '*' for precision: %.*d.
    if let minDigits = format.minDigits {
      appendPrecisionArgument(minDigits)
    }

    // Append the integer.
    addIntHeaders(privacy, sizeForEncoding(T.self))
    arguments.append(number)
    argumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addIntHeaders(_ privacy: OSLogTestHelper.OSLogPrivacy, _ byteCount: Swift.Int) {
    // Append argument header.
    let argumentHeader = getArgumentHeader(privacy: privacy, type: .scalar)
    arguments.append(argumentHeader)

    // Append number of bytes needed to serialize the argument.
    arguments.append(UInt8(byteCount))

    // Increment total byte size by the number of bytes needed for this
    // argument, which is the sum of the byte size of the argument and
    // two bytes needed for the headers.
    totalBytesForSerializingArguments += byteCount + 2

    preamble = getUpdatedPreamble(privacy: privacy, isScalar: true)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func appendPrecisionArgument(_ count: @escaping () -> Swift.Int) {
    appendPrecisionAlignCount(
      count,
      getArgumentHeader(privacy: .auto, type: .count))
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func appendAlignmentArgument(_ count: @escaping () -> Swift.Int) {
    appendPrecisionAlignCount(
      count,
      getArgumentHeader(privacy: .auto, type: .scalar))
  }
  @_transparent @inlinable internal mutating func appendPrecisionAlignCount(_ count: @escaping () -> Swift.Int, _ argumentHeader: Swift.UInt8) {
    arguments.append(argumentHeader)
    // Append number of bytes needed to serialize the argument.
    arguments.append(4)
    // Increment total byte size by the number of bytes needed for this
    // argument, which is the sum of the byte size of the argument and
    // two bytes needed for the headers.
    totalBytesForSerializingArguments += 6
    // The count is expected to be a CInt.
    arguments.append({ CInt(count()) })
    argumentCount += 1
    // Note that we don't have to update the preamble here.
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func appendMaskArgument(_ privacy: OSLogTestHelper.OSLogPrivacy) {
    arguments.append(getArgumentHeader(privacy: .auto, type: .mask))
    // Append number of bytes needed to serialize the mask. Mask is 64 bit payload.
    arguments.append(8)
    // Increment total byte size by the number of bytes needed for this
    // argument, which is the sum of the byte size of the argument and
    // two bytes needed for the headers.
    totalBytesForSerializingArguments += 10
    // Append the mask value. This is a compile-time constant.
    let maskValue = privacy.maskValue
    arguments.append({ maskValue })
    argumentCount += 1
    // Note that we don't have to update the preamble here.
  }
}
extension OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append<T>(_ value: @escaping () -> T) where T : Swift.FixedWidthInteger {
    argumentClosures.append({ (position, _, _) in
      serialize(value(), at: &position)
    })
  }
}
@_transparent @_alwaysEmitIntoClient internal func sizeForEncoding<T>(_ type: T.Type) -> Swift.Int where T : Swift.FixedWidthInteger {
  return type.bitWidth &>> logBitsPerByte
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize<T>(_ value: T, at bufferPosition: inout OSLogTestHelper.ByteBufferPointer) where T : Swift.FixedWidthInteger {
  let byteCount = sizeForEncoding(T.self)
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)
  withUnsafeBytes(of: value) { dest.copyMemory(from: $0) }
  bufferPosition += byteCount
}
extension OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ argumentString: @autoclosure @escaping () -> Swift.String, align: OSLogTestHelper.OSLogStringAlignment = .none, privacy: OSLogTestHelper.OSLogPrivacy = .auto) {
    guard argumentCount < maxOSLogArgumentCount else { return }

    formatString += getStringFormatSpecifier(align, privacy)

    // If minimum column width is specified, append this value first. Note that the
    // format specifier would use a '*' for width e.g. %*s.
    if let minColumns = align.minimumColumnWidth {
      appendAlignmentArgument(minColumns)
    }

    // If the privacy has a mask, append the mask argument, which is a constant payload.
    // Note that this should come after the width but before the precision.
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }

    // Append the string argument.
    addStringHeaders(privacy)
    arguments.append(argumentString)
    argumentCount += 1
    stringArgumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addStringHeaders(_ privacy: OSLogTestHelper.OSLogPrivacy) {
    // Append argument header.
    let header = getArgumentHeader(privacy: privacy, type: .string)
    arguments.append(header)

    // Append number of bytes needed to serialize the argument.
    let byteCount = pointerSizeInBytes()
    arguments.append(UInt8(byteCount))

    // Increment total byte size by the number of bytes needed for this
    // argument, which is the sum of the byte size of the argument and
    // two bytes needed for the headers.
    totalBytesForSerializingArguments += byteCount + 2

    preamble = getUpdatedPreamble(privacy: privacy, isScalar: false)
  }
  @inlinable @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getStringFormatSpecifier(_ align: OSLogTestHelper.OSLogStringAlignment, _ privacy: OSLogTestHelper.OSLogPrivacy) -> Swift.String {
    var specifier = "%"
    if let privacySpecifier = privacy.privacySpecifier {
      specifier += "{"
      specifier += privacySpecifier
      specifier += "}"
    }
    if case .start = align.anchor {
      specifier += "-"
    }
    if let _ = align.minimumColumnWidth {
      specifier += "*"
    }
    specifier += "s"
    return specifier
  }
}
extension OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ value: @escaping () -> Swift.String) {
    argumentClosures.append({ (position, _, stringArgumentOwners) in
      serialize(
        value(),
        at: &position,
        storingStringOwnersIn: &stringArgumentOwners)
    })
  }
}
@_transparent @_alwaysEmitIntoClient internal func pointerSizeInBytes() -> Swift.Int {
  return Int.bitWidth &>> logBitsPerByte
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize(_ stringValue: Swift.String, at bufferPosition: inout Swift.UnsafeMutablePointer<Swift.UInt8>, storingStringOwnersIn stringArgumentOwners: inout OSLogTestHelper.ObjectStorage<Any>) {
  let stringPointer =
    getNullTerminatedUTF8Pointer(
      stringValue,
      storingStringOwnersIn: &stringArgumentOwners)

  let byteCount = pointerSizeInBytes()
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)
  withUnsafeBytes(of: stringPointer) { dest.copyMemory(from: $0) }
  bufferPosition += byteCount
}
@_alwaysEmitIntoClient @inline(never) internal func getNullTerminatedUTF8Pointer(_ stringValue: Swift.String, storingStringOwnersIn stringArgumentOwners: inout OSLogTestHelper.ObjectStorage<Any>) -> Swift.UnsafeRawPointer {
  let (optStorage, bytePointer, _, _, _):
    (AnyObject?, UnsafeRawPointer, Int, Bool, Bool) =
     stringValue._deconstructUTF8(scratch: nil)
  if let storage = optStorage {
    initializeAndAdvance(&stringArgumentOwners, to: storage)
  } else {
    initializeAndAdvance(&stringArgumentOwners, to: stringValue._guts)
  }
  return bytePointer
}
extension OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ argumentObject: @autoclosure @escaping () -> ObjectiveC.NSObject, privacy: OSLogTestHelper.OSLogPrivacy = .auto) {
    guard argumentCount < maxOSLogArgumentCount else { return }

    formatString += getNSObjectFormatSpecifier(privacy)
    // If the privacy has a mask, append the mask argument, which is a constant payload.
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }
    addNSObjectHeaders(privacy)
    arguments.append(argumentObject)
    argumentCount += 1
    objectArgumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addNSObjectHeaders(_ privacy: OSLogTestHelper.OSLogPrivacy) {
    // Append argument header.
    let header = getArgumentHeader(privacy: privacy, type: .object)
    arguments.append(header)

    // Append number of bytes needed to serialize the argument.
    let byteCount = pointerSizeInBytes()
    arguments.append(UInt8(byteCount))

    // Increment total byte size by the number of bytes needed for this
    // argument, which is the sum of the byte size of the argument and
    // two bytes needed for the headers.
    totalBytesForSerializingArguments += byteCount + 2

    preamble = getUpdatedPreamble(privacy: privacy, isScalar: false)
  }
  @inlinable @_semantics("constant_evaluable") @_effects(readonly) @_optimize(none) internal func getNSObjectFormatSpecifier(_ privacy: OSLogTestHelper.OSLogPrivacy) -> Swift.String {
    var specifier = "%"
    if let privacySpecifier = privacy.privacySpecifier {
      specifier += "{"
      specifier += privacySpecifier
      specifier += "}"
    }
    specifier += "@"
    return specifier
  }
}
extension OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ value: @escaping () -> ObjectiveC.NSObject) {
    argumentClosures.append({ (position, objectArguments, _) in
      serialize(value(), at: &position, storingObjectsIn: &objectArguments)
    })
  }
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize(_ object: ObjectiveC.NSObject, at bufferPosition: inout OSLogTestHelper.ByteBufferPointer, storingObjectsIn objectArguments: inout OSLogTestHelper.ObjectStorage<ObjectiveC.NSObject>) {
  let byteCount = pointerSizeInBytes();
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)
  // Get the address of this NSObject as an UnsafeRawPointer.
  let objectAddress = Unmanaged.passUnretained(object).toOpaque()
  // Copy the address into the destination buffer. Note that the input NSObject
  // is kept alive until the os_log ABI call completes by storing in the
  // objectArguments.
  withUnsafeBytes(of: objectAddress) { dest.copyMemory(from: $0) }
  bufferPosition += byteCount
  // This object could be newly created by the auto-closure. Therefore, make
  // sure it is alive until the log call completes.
  initializeAndAdvance(&objectArguments, to: object)
}
extension OSLogInterpolation {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Float, format: OSLogTestHelper.OSLogFloatFormatting = .fixed, align: OSLogTestHelper.OSLogStringAlignment = .none, privacy: OSLogTestHelper.OSLogPrivacy = .auto) {
    appendInterpolation(
      Double(number()),
      format: format,
      align: align,
      privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ number: @autoclosure @escaping () -> Swift.Double, format: OSLogTestHelper.OSLogFloatFormatting = .fixed, align: OSLogTestHelper.OSLogStringAlignment = .none, privacy: OSLogTestHelper.OSLogPrivacy = .auto) {
    guard argumentCount < maxOSLogArgumentCount else { return }
    formatString +=
      format.formatSpecifier(for: Double.self, align: align, privacy: privacy)

    // If minimum column width is specified, append this value first. Note that
    // the format specifier would use a '*' for width e.g. %*f.
    if let minColumns = align.minimumColumnWidth {
      appendAlignmentArgument(minColumns)
    }

    // If the privacy has a mask, append the mask argument, which is a constant payload.
    // Note that this should come after the width but before the precision.
    if privacy.hasMask {
      appendMaskArgument(privacy)
    }

    // If minimum number of digits (precision) is specified, append the
    // precision before the argument. Note that the format specifier would use
    // a '*' for precision: %.*f.
    if let precision = format.precision {
      appendPrecisionArgument(precision)
    }
    // Append the double.
    addDoubleHeaders(privacy)
    arguments.append(number)
    argumentCount += 1
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func addDoubleHeaders(_ privacy: OSLogTestHelper.OSLogPrivacy) {
    // Append argument header.
    let argumentHeader = getArgumentHeader(privacy: privacy, type: .scalar)
    arguments.append(argumentHeader)

    // Append number of bytes needed to serialize the argument.
    let byteCount = doubleSizeInBytes()
    arguments.append(UInt8(byteCount))

    // Increment total byte size by the number of bytes needed for this
    // argument, which is the sum of the byte size of the argument and
    // two bytes needed for the headers.
    totalBytesForSerializingArguments += byteCount + 2

    preamble = getUpdatedPreamble(privacy: privacy, isScalar: true)
  }
}
extension OSLogArguments {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal mutating func append(_ value: @escaping () -> Swift.Double) {
    argumentClosures.append({ (position, _, _) in
      serialize(value(), at: &position)
    })
  }
}
@_transparent @_alwaysEmitIntoClient internal func doubleSizeInBytes() -> Swift.Int {
  return 8
}
@_alwaysEmitIntoClient @inline(__always) internal func serialize(_ value: Swift.Double, at bufferPosition: inout OSLogTestHelper.ByteBufferPointer) {
  let byteCount = doubleSizeInBytes()
  let dest =
    UnsafeMutableRawBufferPointer(start: bufferPosition, count: byteCount)
  withUnsafeBytes(of: value) { dest.copyMemory(from: $0) }
  bufferPosition += byteCount
}
extension OSLogInterpolation {
  @_optimize(none) @_transparent @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation<T>(_ value: @autoclosure @escaping () -> T, align: OSLogTestHelper.OSLogStringAlignment = .none, privacy: OSLogTestHelper.OSLogPrivacy = .auto) where T : Swift.CustomStringConvertible {
    // TODO: Dead code elimination does not remove the call to the default value
    // of alignment: .none. This function is made @_transparent to work around
    // that.
    appendInterpolation(value().description, align: align, privacy: privacy)
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) @_semantics("oslog.requires_constant_arguments") public mutating func appendInterpolation(_ value: @autoclosure @escaping () -> Any.Type, align: OSLogTestHelper.OSLogStringAlignment = .none, privacy: OSLogTestHelper.OSLogPrivacy = .auto) {
    appendInterpolation(
      _typeName(value(), qualified: false),
      align: align,
      privacy: privacy)
  }
}
@frozen public struct OSLogPrivacy {
  @usableFromInline
  internal enum PrivacyOption {
    case `private`
    case `public`
    case auto
    @usableFromInline
    internal static func == (a: OSLogTestHelper.OSLogPrivacy.PrivacyOption, b: OSLogTestHelper.OSLogPrivacy.PrivacyOption) -> Swift.Bool
    @usableFromInline
    internal var hashValue: Swift.Int {
      @usableFromInline
      get
    }
    @usableFromInline
    internal func hash(into hasher: inout Swift.Hasher)
  }
  public enum Mask {
    case hash
    case none
    public static func == (a: OSLogTestHelper.OSLogPrivacy.Mask, b: OSLogTestHelper.OSLogPrivacy.Mask) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @usableFromInline
  internal var privacy: OSLogTestHelper.OSLogPrivacy.PrivacyOption
  @usableFromInline
  internal var mask: OSLogTestHelper.OSLogPrivacy.Mask
  @usableFromInline
  @_transparent internal init(privacy: OSLogTestHelper.OSLogPrivacy.PrivacyOption, mask: OSLogTestHelper.OSLogPrivacy.Mask) {
    self.privacy = privacy
    self.mask = mask
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static var `public`: OSLogTestHelper.OSLogPrivacy {
    get {
    OSLogPrivacy(privacy: .public, mask: .none)
  }
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static var `private`: OSLogTestHelper.OSLogPrivacy {
    get {
    OSLogPrivacy(privacy: .private, mask: .none)
  }
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static func `private`(mask: OSLogTestHelper.OSLogPrivacy.Mask) -> OSLogTestHelper.OSLogPrivacy {
    OSLogPrivacy(privacy: .private, mask: mask)
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static var auto: OSLogTestHelper.OSLogPrivacy {
    get {
    OSLogPrivacy(privacy: .auto, mask: .none)
  }
  }
  @_semantics("constant_evaluable") @_optimize(none) @inlinable public static func auto(mask: OSLogTestHelper.OSLogPrivacy.Mask) -> OSLogTestHelper.OSLogPrivacy {
    OSLogPrivacy(privacy: .auto, mask: mask)
  }
  @inlinable @_semantics("constant_evaluable") @_optimize(none) internal var argumentFlag: Swift.UInt8 {
    get {
    switch privacy {
    case .private:
      return 0x1
    case .public:
      return 0x2
    default:
      return 0
    }
  }
  }
  @inlinable @_semantics("constant_evaluable") @_optimize(none) internal var isAtleastPrivate: Swift.Bool {
    get {
    switch privacy {
    case .public:
      return false
    case .auto:
      return false
    default:
      return true
    }
  }
  }
  @inlinable @_semantics("constant_evaluable") @_optimize(none) internal var needsPrivacySpecifier: Swift.Bool {
    get {
    if case .hash = mask {
      return true
    }
    switch privacy {
    case .auto:
      return false
    default:
      return true
    }
  }
  }
  @inlinable @_transparent internal var hasMask: Swift.Bool {
    @_transparent get {
    if case .hash = mask {
      return true
    }
    return false
  }
  }
  @inlinable @_transparent internal var maskValue: Swift.UInt64 {
    @_transparent get {
    // Return the value of
    // 'h' | 'a' << 8 | 's' << 16 | 'h' << 24 which equals
    // 104  |  (97 << 8) | (115 << 16) | (104 << 24)
    1752392040
  }
  }
  @inlinable @_semantics("constant_evaluable") @_optimize(none) internal var privacySpecifier: Swift.String? {
    get {
    let hasMask = self.hasMask
    var isAuto = false
    if case .auto = privacy {
      isAuto = true
    }
    if isAuto, !hasMask {
      return nil
    }
    var specifier: String
    switch privacy {
    case .public:
      specifier = "public"
    case .private:
      specifier = "private"
    default:
      specifier = ""
    }
    if hasMask {
      if !isAuto {
        specifier += ","
      }
      specifier += "mask.hash"
    }
    return specifier
  }
  }
}
@frozen public struct OSLogFloatFormatting {
  @usableFromInline
  internal var explicitPositiveSign: Swift.Bool
  @usableFromInline
  internal var uppercase: Swift.Bool
  @usableFromInline
  internal var precision: (() -> Swift.Int)?
  @usableFromInline
  internal enum Notation {
    case hex
    case fixed
    case exponential
    case hybrid
    @usableFromInline
    internal static func == (a: OSLogTestHelper.OSLogFloatFormatting.Notation, b: OSLogTestHelper.OSLogFloatFormatting.Notation) -> Swift.Bool
    @usableFromInline
    internal var hashValue: Swift.Int {
      @usableFromInline
      get
    }
    @usableFromInline
    internal func hash(into hasher: inout Swift.Hasher)
  }
  @usableFromInline
  internal var notation: OSLogTestHelper.OSLogFloatFormatting.Notation
  @usableFromInline
  @_transparent internal init(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false, precision: (() -> Swift.Int)?, notation: OSLogTestHelper.OSLogFloatFormatting.Notation) {
    self.explicitPositiveSign = explicitPositiveSign
    self.uppercase = uppercase
    self.precision = precision
    self.notation = notation
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var fixed: OSLogTestHelper.OSLogFloatFormatting {
    get { .fixed() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func fixed(precision: @autoclosure @escaping () -> Swift.Int, explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: precision,
      notation: .fixed
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func fixed(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: nil,
      notation: .fixed
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var hex: OSLogTestHelper.OSLogFloatFormatting {
    get { .hex() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hex(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: nil,
      notation: .hex
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var exponential: OSLogTestHelper.OSLogFloatFormatting {
    get { .exponential() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func exponential(precision: @autoclosure @escaping () -> Swift.Int, explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: precision,
      notation: .exponential
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func exponential(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: nil,
      notation: .exponential
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static var hybrid: OSLogTestHelper.OSLogFloatFormatting {
    get { .hybrid() }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hybrid(precision: @autoclosure @escaping () -> Swift.Int, explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: precision,
      notation: .hybrid
    )
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) public static func hybrid(explicitPositiveSign: Swift.Bool = false, uppercase: Swift.Bool = false) -> OSLogTestHelper.OSLogFloatFormatting {
    return OSLogFloatFormatting(
      explicitPositiveSign: explicitPositiveSign,
      uppercase: uppercase,
      precision: nil,
      notation: .hybrid
    )
  }
}
extension OSLogFloatFormatting {
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal static func _formatStringLengthModifier<I>(_ type: I.Type) -> Swift.String? where I : Swift.FloatingPoint {
    switch type {
    //   fprintf formatters promote Float to Double
    case is Float.Type: return ""
    case is Double.Type: return ""
    //   fprintf formatters use L for Float80
    case is Float80.Type: return "L"
    default: return nil
    }
  }
  @_semantics("constant_evaluable") @inlinable @_optimize(none) internal func formatSpecifier<I>(for type: I.Type, align: OSLogTestHelper.OSLogStringAlignment, privacy: OSLogTestHelper.OSLogPrivacy) -> Swift.String where I : Swift.FloatingPoint {
    var specification = "%"
    // Add privacy qualifier after % sign within curly braces. This is an
    // os log specific flag.
    if let privacySpecifier = privacy.privacySpecifier {
      specification += "{"
      specification += privacySpecifier
      specification += "}"
    }

    // 1. Flags
    // IEEE: `+` The result of a signed conversion shall always begin with a sign
    // ( '+' or '-' )
    if explicitPositiveSign {
      specification += "+"
    }

    // IEEE: `-` The result of the conversion shall be left-justified within the field.
    // The conversion is right-justified if this flag is not specified.
    if case .start = align.anchor {
      specification += "-"
    }

    if let _ = align.minimumColumnWidth {
      // The alignment could be a dynamic value. Therefore, use a star here and pass it
      // as an additional argument.
      specification += "*"
    }

    if let _ = precision {
      specification += ".*"
    }

    guard let lengthModifier =
      OSLogFloatFormatting._formatStringLengthModifier(type) else {
      fatalError("Float type has unknown length")
    }
    specification += lengthModifier

    // 3. Precision and conversion specifier.
    switch notation {
    case .fixed:
      specification += (uppercase ? "F" : "f")
    case .exponential:
      specification += (uppercase ? "E" : "e")
    case .hybrid:
      specification += (uppercase ? "G" : "g")
    case .hex:
      //guard type.radix == 2 else { return nil }
      specification += (uppercase ? "A" : "a")
    default:
      fatalError("Unknown float notation")
    }
    return specification
  }
}
extension OSLogTestHelper.OSLogInterpolation.ArgumentType : Swift.Equatable {}
extension OSLogTestHelper.OSLogInterpolation.ArgumentType : Swift.Hashable {}
extension OSLogTestHelper.OSLogCollectionBound : Swift.Equatable {}
extension OSLogTestHelper.OSLogCollectionBound : Swift.Hashable {}
extension OSLogTestHelper.OSLogPrivacy.PrivacyOption : Swift.Equatable {}
extension OSLogTestHelper.OSLogPrivacy.PrivacyOption : Swift.Hashable {}
extension OSLogTestHelper.OSLogPrivacy.Mask : Swift.Equatable {}
extension OSLogTestHelper.OSLogPrivacy.Mask : Swift.Hashable {}
extension OSLogTestHelper.OSLogFloatFormatting.Notation : Swift.Equatable {}
extension OSLogTestHelper.OSLogFloatFormatting.Notation : Swift.Hashable {}
